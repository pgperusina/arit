options {
  IGNORE_CASE = true;
  STATIC = false;
//  DEBUG_LOOKAHEAD = true;
//  DEBUG_PARSER = true;
}

PARSER_BEGIN(Gramatica)

package analizador.descendente;

import abstracto.AST;
import expresiones.Funcion;
import expresiones.Identificador;
import expresiones.ExpresionLogica;
import expresiones.ExpresionLogica.OperadorLogico;
import expresiones.ExpresionTernaria;
import expresiones.ExpresionAritmetica;
import expresiones.ExpresionAritmetica.OperadorAritmetico;
import expresiones.ExpresionRelacional;
import expresiones.ExpresionRelacional.OperadorRelacional;
import instrucciones.For;
import instrucciones.While;
import instrucciones.DoWhile;
import instrucciones.If;
import instrucciones.Switch;
import expresiones.Case;
import expresiones.Default;
import instrucciones.Return;
import instrucciones.Break;
import instrucciones.Continue;
import expresiones.Llamada;
import expresiones.ArgumentoDefault;
import instrucciones.AsignacionIndiceEstructura;
import expresiones.AccesoEstructura;
import expresiones.Valor;
import expresiones.IndiceTipoUno;
import expresiones.IndiceTipoDos;
import expresiones.IndiceTipoUnoMatriz;
import expresiones.IndiceTipoDosMatriz;
import expresiones.IndiceTipoTresMatriz;
import instrucciones.Declaracion;
import excepciones.Excepcion;
import estructuras.Vector;
import tablasimbolos.Arbol;
import tablasimbolos.Tipo;
import tablasimbolos.Tipo.TipoDato;
import tablasimbolos.Tipo.TipoEstructura;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Arrays;

public class Gramatica {
    public LinkedList<Excepcion> listaExcepciones = new LinkedList<>();

}
PARSER_END(Gramatica)

/** Lexico */

/* Comments */
<IN_LINE_COMMENT> SKIP:
{
   "\n" : DEFAULT
}

<IN_LINE_COMMENT> MORE:
{
  < ~[] >
}

<MULTI_LINE_COMMENT> SKIP:
{
   "*#" : DEFAULT
}

<MULTI_LINE_COMMENT> MORE:
{
  < ~[] >
}

TOKEN : {
      <INTEGER: (["0"-"9"])+>
    | <NUMERIC: (["0"-"9"])+"."(["0"-"9"])+>
    | <BOOLEAN: ("true"|"false")>
    | <NULL: "null">
    | <FOR: "for">
    | <IN: "in">
    | <DO: "do">
    | <WHILE: "while">
    | <SWITCH: "switch">
    | <CASE: "case">
    | <DEFAULT_WORD: "default">
    | <IF: "if">
    | <ELSE: "else">
    | <COMA: ",">
    | <PCOMA: ";">
    | <PARINI: "(">
    | <PAREND: ")">
    | <CORI: "[">
    | <CORD: "]">
    | <LLAVEI: "{">
    | <LLAVED: "}">
    | <MAS: "+">
    | <MENOS: "-">
    | <POR: "*">
    | <DIV: "/">
    | <POTENCIA: "^">
    | <MODULO: "%%">
    | <IGUAL: "=">
    | <MENORQUE: "<">
    | <MAYORQUE: ">">
    | <MENORIGUAL: "<=">
    | <MAYORIGUAL: ">=">
    | <IGUALA: "==">
    | <DIFERENTEDE: "!=">
    | <AND: "&">
    | <OR: "|">
    | <NOT: "!" >
    | <QUESTION_MARK: "?" >
    | <DOS_PUNTOS: ":" >
    | <FUNCION: "function" >
    | <RETORNO: "return" >
    | <BREAK: "break" >
    | <CONTINUE: "continue" >
    | <IDENTIFICADOR: (["a"-"z"] | "." ("." | ["a"-"z"] | "_"  )+ ) ("." | ["a"-"z"] | "_" | ["0"-"9"] )* >
}

/**
* STRING Tokens
* **/
MORE :
{
    "\"" : STRING_STATE
}

<STRING_STATE> MORE :
{
    <~["\""]>
}

<STRING_STATE> TOKEN:
{
   <STRING:"\""> { /*matchedToken.image = image.toString().trim();*/ } : DEFAULT
}

SKIP : {
      " "
    | "\t"
    | "\r"
    | "\n"
    | <"#*"> : MULTI_LINE_COMMENT
    | <"#">  : IN_LINE_COMMENT
    | <(~[])> {
//            LinkedList<Excepcion> listaExcepciones = new LinkedList<>();
//            listaExcepciones.add(new Excepcion("Léxico", "Caracter no aceptado '"+ image.toString()+ "'.", input_stream.line, input_stream.column));
            System.out.println("Léxico -- Caracter no aceptado '"+ image.toString()+ "' [Fila: " + input_stream.line + ", Columna: " + input_stream.column + "]");
//            throw new ParseException();
//            this.listaExcepciones.add(new Excepcion("Sintáctico", "Caracter no esperado", 1000,1000));
        }
}

/**  FIN LEXICO **/


/************** INICIO PARSER ****************/


ArrayList<AST> analizar(ArrayList<AST> instrucciones) :
{ AST e;}
{
   try {
        ( e = instruccion() { instrucciones.add(e); } )+
         <EOF> {return instrucciones;}
   } catch (ParseException ex) {
           Token t;
           listaExcepciones.add(new Excepcion("Sintáctico", "Caracter no esperado '"+ ex.currentToken.next.image +"'. Se esperaba '"+ex.tokenImage[0]+"' o '"+ex.tokenImage[1]+"'.",ex.currentToken.next.beginLine,ex.currentToken.next.beginColumn));
           do {
               t = getNextToken();
               if(t.kind == EOF){
                return instrucciones;
               }
            } while (t.kind != PCOMA && t!=null && t.kind != EOF );
           return analizar(instrucciones);
   }
}


 /**
 * instruccion -> declaracion
*/
AST instruccion() :
{AST e;}
{
    LOOKAHEAD(5) e = funcion() { return e; }
    |
    LOOKAHEAD(2) e = declaracion() { return e; }
    |
    LOOKAHEAD(2) e = llamada() (<PCOMA>)? { return e; }
    |
    e = asignacionIndiceEstructura() (<PCOMA>)? { return e; }
    |
    e = retorno() { return e; }
    |
    e = insBreak() { return e; }
    |
    e = insContinue() { return e; }
    |
    e = sentenciaIf() { return e; }
    |
    e = cicloFor() { return e; }
    |
    e = cicloWhile() { return e; }
    |
    e = cicloDoWhile() (<PCOMA>)? { return e; }
    |
    e = Switch() { return e; }

}

/**
* declaracion -> ID = expresion (;)?
*/
AST declaracion() :
{ Token id; AST e; }
{
    id = <IDENTIFICADOR> <IGUAL> e = expresion() (<PCOMA>)?
    { return new Declaracion(id.image.trim(), e, token.beginLine, token.beginColumn); }

}

/**
* funcion -> ID = function(lista_parametros) { (instruccion)+ }
*/
AST funcion() :
{ Token id; ArrayList<AST> listaParametros, bloqueInstrucciones; AST e; }
{
    LOOKAHEAD(3) id = <IDENTIFICADOR> <IGUAL> <PARINI> listaParametros = listaParametros() <PAREND>
    <IGUAL><MAYORQUE> bloqueInstrucciones = bloqueInstrucciones()
    { return new Funcion(id.image.trim(), listaParametros, bloqueInstrucciones, token.beginLine, token.beginColumn); }
    |
    id = <IDENTIFICADOR> <IGUAL>  <FUNCION> <PARINI>
        listaParametros = listaParametros() <PAREND> bloqueInstrucciones = bloqueInstrucciones()
    { return new Funcion(id.image.trim(), listaParametros, bloqueInstrucciones, token.beginLine, token.beginColumn); }

}

/**
* asignacionIndiceEstructura -> ID([expresion])+ = expresion (;)?
*/
AST asignacionIndiceEstructura() :
{ LinkedList<AST> posiciones; AST valor; Token t;}
{
    t = <IDENTIFICADOR> posiciones = indicesAcceso() <IGUAL> valor = expresion()
    { return new AsignacionIndiceEstructura(t.image, posiciones, valor, token.beginLine, token.beginColumn);}
}

AST accesoEstructura() :
{ LinkedList<AST> posiciones; Token t;}
{
    t = <IDENTIFICADOR> posiciones = indicesAcceso()
    { return new AccesoEstructura(t.image, posiciones, token.beginLine, token.beginColumn);}
}

LinkedList<AST> indicesAcceso() :
{LinkedList<AST> lista = new LinkedList<AST>(); AST e, e1, r;}
{
    LOOKAHEAD(3) <CORI> e = expresion()  <CORD>
    { lista.add(new IndiceTipoUno(e, token.beginLine, token.beginColumn)); }
    (
        LOOKAHEAD(2) <CORI><CORI> e = expresion() <CORD><CORD>
        { lista.add(new IndiceTipoDos(e, token.beginLine, token.beginColumn)); }
        |
        <CORI> e = expresion() <CORD>
        { lista.add(new IndiceTipoUno(e, token.beginLine, token.beginColumn)); }
    )*
    {return lista; }
    |
    LOOKAHEAD(3) <CORI> e = expresion() <COMA>
    { r = new IndiceTipoDosMatriz(e, token.beginLine, token.beginColumn); }
    (
        e1 = expresion()
        { r = new IndiceTipoUnoMatriz(e, e1, token.beginLine, token.beginColumn); }
    )?
    <CORD>
    {
        lista.add(r);
        return lista;
    }
    |
    LOOKAHEAD(2) <CORI><CORI> e = expresion() <CORD><CORD>
    { lista.add(new IndiceTipoDos(e, token.beginLine, token.beginColumn)); }
    (
        LOOKAHEAD(2) <CORI><CORI> e = expresion()  <CORD><CORD>
        { lista.add(new IndiceTipoDos(e, token.beginLine, token.beginColumn)); }
        |
        <CORI> e = expresion() <CORD>
        { lista.add(new IndiceTipoUno(e, token.beginLine, token.beginColumn)); }
    )*
    { return lista;}
    |
    LOOKAHEAD(2) <CORI> <COMA> e = expresion() <CORD>
    {
        lista.add(new IndiceTipoTresMatriz(e, token.beginLine, token.beginColumn));
        return lista;
    }
}

AST llamada() :
{ArrayList<AST> expresiones; Token t;}
{
    t=<IDENTIFICADOR> <PARINI> expresiones=listaExpresiones() <PAREND>
    { return new Llamada(t.image.trim(), expresiones, t.beginLine, t.beginColumn); }
}

ArrayList<AST> listaExpresiones() :
{ArrayList<AST> lista = new ArrayList<AST>(); AST e;}
{
    (
        e=expresion() {lista.add(e);}
        (
            LOOKAHEAD(2) <COMA> e=expresion() {lista.add(e);}
        )*
    )?
    {return lista;}

}

/**
* listaParametros -> expresion ( ',' expresion )*
*/
ArrayList<AST> listaParametros() :
{ Token id, id2; AST e, e1; ArrayList<AST> listaParametros = new ArrayList<AST>(); }
{
    (
        id = <IDENTIFICADOR>
        {
            e = new Identificador(id.image.trim(), token.beginLine, token.beginColumn);
        }
        ( <IGUAL> e = expresion()
            {
                e = new Declaracion(id.image.trim(), e, token.beginLine, token.beginColumn);
            }
        )?
        { listaParametros.add(e); }
        (
            LOOKAHEAD(2) <COMA> id2 = <IDENTIFICADOR>
            {
                e1 = new Identificador(id2.image.trim(), token.beginLine, token.beginColumn);
            }
            ( <IGUAL> e1 = expresion()
                {
                    e1 = new Declaracion(id2.image.trim(), e1, token.beginLine, token.beginColumn);
                }
            )?
            { listaParametros.add(e1); }
        )*
    )?
    { return listaParametros; }
}

/**
* bloqueInstrucciones -> { (instruccion)* }
*/
ArrayList<AST> bloqueInstrucciones() :
{ ArrayList<AST> instrucciones = new ArrayList<AST>(); AST e;}
{
    <LLAVEI> (e = instruccion() { instrucciones.add(e); } )* <LLAVED>
    { return instrucciones; }
}

AST sentenciaIf() :
{ AST e, e1; ArrayList<AST> instruccionesIf, instruccionesElse = new ArrayList<AST>(); }{
    <IF> <PARINI> e = expresion() <PAREND> instruccionesIf = bloqueInstrucciones()
    (
        LOOKAHEAD(2) <ELSE> e1 = sentenciaIf() { instruccionesElse.add(e1); }
        |
        <ELSE> instruccionesElse = bloqueInstrucciones()
    )?
    {
        return new If(e, instruccionesIf, instruccionesElse, token.beginLine, token.beginColumn);
    }
}

AST cicloFor() :
{ AST e; Token id; ArrayList<AST> instrucciones; }
{
    <FOR> <PARINI> id = <IDENTIFICADOR> <IN> e = expresion() <PAREND> instrucciones = bloqueInstrucciones()
    { return new For(id.image, e, instrucciones, token.beginLine, token.beginColumn); }
}

AST cicloWhile() :
{ AST e; ArrayList<AST> instrucciones; }
{
    <WHILE> <PARINI> e = expresion() <PAREND> instrucciones = bloqueInstrucciones()
    { return new While(e, instrucciones, token.beginLine, token.beginColumn); }
}

AST cicloDoWhile() :
{ AST e; ArrayList<AST> instrucciones; }
{
    <DO> instrucciones = bloqueInstrucciones() <WHILE> <PARINI> e = expresion() <PAREND>
    { return new DoWhile(e, instrucciones, token.beginLine, token.beginColumn); }
}

AST Switch() :
{ AST e; ArrayList<AST> listaCases; }
{
    <SWITCH> <PARINI> e = expresion() <PAREND> <LLAVEI> listaCases = bloqueCases() <LLAVED>
    { return new Switch(e, listaCases, token.beginLine, token.beginColumn); }
}

ArrayList<AST> bloqueCases() :
{ ArrayList<AST> bloqueCases = new ArrayList<AST>(); AST e; }
{
    ( e = Case() { bloqueCases.add(e); })+
    { return bloqueCases; }
}


AST Case() :
{ AST e, i; ArrayList<AST> instrucciones = new ArrayList<AST>(); Token id;}
{
    <CASE> e = expresion() <DOS_PUNTOS>
        (
            LOOKAHEAD(2) i = instruccion() { instrucciones.add(i); }
        )*
    (<BREAK> (<PCOMA>)? )?
    { return new Case(e, instrucciones, token.beginLine, token.beginColumn); }
    |
    id = <DEFAULT_WORD> <DOS_PUNTOS>
        (
            LOOKAHEAD(2) i = instruccion() { instrucciones.add(i); }
        )*
    (<BREAK> (<PCOMA>)? )?
    { return new Case(new Default(), instrucciones, token.beginLine, token.beginColumn); }
}

AST insBreak() :
{AST e;}
{
    <BREAK> (<PCOMA>)? { return new Break(token.beginLine, token.beginColumn); }
}

AST insContinue() :
{AST e;}
{
    <CONTINUE> (<PCOMA>)? { return new Continue(token.beginLine, token.beginColumn); }
}

AST retorno() :
{AST e;}
{
    LOOKAHEAD(3) <RETORNO> <PARINI> <PAREND> (<PCOMA>)? {return new Return(token.beginLine, token.beginColumn);}
    |
    <RETORNO> <PARINI> e=expresion() <PAREND> (<PCOMA>)? {return new Return(e, token.beginLine, token.beginColumn);}

}


/**
* expresion ->  condicion ? exp1 : exp1 [;]
*/
AST expresion() :
{ AST e, e1, e2; }
{
    e = expresionOr()
    (
        LOOKAHEAD(2) <QUESTION_MARK> e1 = expresion() <DOS_PUNTOS> e2 = expresion()
        { e = new ExpresionTernaria(e, e1, e2, token.beginLine, token.beginColumn); }
    )*
    { return e; }
}

/**
*   expresionOr -> expresionAnd ( '|' expresionAnd )*
*/
AST expresionOr() :
{ AST e, e1; }
{
    e = expresionAnd()
    (
        <OR> e1 = expresionAnd() { e = new ExpresionLogica(e, e1, OperadorLogico.OR, token.beginLine, token.beginColumn); }
    )*
    { return e; }
}

/**
*   expresionAnd -> expresionIgualdad ( '&' expresionIgualdad )*
*/
AST expresionAnd() :
{ AST e, e1; }
{
    e = expresionIgualdad()
    (
        <AND> e1 = expresionIgualdad() { e = new ExpresionLogica(e, e1, OperadorLogico.AND, token.beginLine, token.beginColumn); }
    )*
    { return e; }
}

/**
*   expresionAnd -> expresionRelacional ( '==' expresionRelacional )*
                |   expresionRelacional ( '!=' expresionRelacional )*
*/
AST expresionIgualdad() :
{ AST e, e1; }
{
    e = expresionRelacional()
    (
        <DIFERENTEDE> e1 = expresionRelacional() { e = new ExpresionRelacional(e, e1, OperadorRelacional.DIFERENTEDE, token.beginLine, token.beginColumn); }
        |
        <IGUALA> e1 = expresionRelacional() { e = new ExpresionRelacional(e, e1, OperadorRelacional.IGUALA, token.beginLine, token.beginColumn); }

    )*
    { return e; }
}

/**
*   expresionRelacional -> expresionAditiva ( '<' expresionAditiva )*
                |   expresionAditiva ( '>' expresionAditiva )*
                |   expresionAditiva ( '<=' expresionAditiva )*
                |   expresionAditiva ( '>=' expresionAditiva )*
*/
AST expresionRelacional() :
{ AST e, e1; }
{
    e = expresionAditiva()
    (
        <MENORQUE> e1 = expresionAditiva() { e = new ExpresionRelacional(e, e1, OperadorRelacional.MENORQUE, token.beginLine, token.beginColumn); }
        |
        <MAYORQUE> e1 = expresionAditiva() { e = new ExpresionRelacional(e, e1, OperadorRelacional.MAYORQUE, token.beginLine, token.beginColumn); }
        |
        <MENORIGUAL> e1 = expresionAditiva() { e = new ExpresionRelacional(e, e1, OperadorRelacional.MENORIGUAL, token.beginLine, token.beginColumn); }
        |
        <MAYORIGUAL> e1 = expresionAditiva() { e = new ExpresionRelacional(e, e1, OperadorRelacional.MAYORIGUAL, token.beginLine, token.beginColumn); }
    )*
    { return e; }
}

/**
*   expresionAditiva -> expresionMultiplicativa ( '+' expresionMultiplicativa )*
                |   expresionMultiplicativa ( '-' expresionMultiplicativa )*
*/
AST expresionAditiva() :
{ AST e, e1; }
{
    e = expresionMultiplicativa()
    (
        <MAS> e1 = expresionMultiplicativa() { e = new ExpresionAritmetica(e, e1, OperadorAritmetico.SUMA, token.beginLine, token.beginColumn); }
        |
        <MENOS> e1 = expresionMultiplicativa() { e = new ExpresionAritmetica(e, e1, OperadorAritmetico.RESTA, token.beginLine, token.beginColumn); }
    )*
    { return e; }
}

/**
*   expresionMultiplicativa -> expresionUnaria ( '*' expresionUnaria )*
                |   expresionUnaria ( '/' expresionUnaria )*
*/
AST expresionMultiplicativa() :
{ AST e, e1; }
{
    e = expresionUnaria()
    (
        <POR> e1 = expresionUnaria() { e = new ExpresionAritmetica(e, e1, OperadorAritmetico.MULTIPLICACION, token.beginLine, token.beginColumn); }
        |
        <DIV> e1 = expresionUnaria() { e = new ExpresionAritmetica(e, e1, OperadorAritmetico.DIVISION, token.beginLine, token.beginColumn); }
        |
        <POTENCIA> e1 = expresionUnaria() { e = new ExpresionAritmetica(e, e1, OperadorAritmetico.POTENCIA, token.beginLine, token.beginColumn); }
        |
        <MODULO> e1 = expresionUnaria() { e = new ExpresionAritmetica(e, e1, OperadorAritmetico.MODULO, token.beginLine, token.beginColumn); }
    )*
    { return e; }
}

AST expresionUnaria() :
{ AST e, e1; }
{
    <MENOS> e = expresionUnaria() { return new ExpresionAritmetica(e, OperadorAritmetico.MENOSUNARIO, token.beginLine, token.beginColumn); }
    |
    <NOT> e = expresionUnaria() { return new ExpresionLogica(e, OperadorLogico.NOT, token.beginLine, token.beginColumn); }
    |
    e = valor() { return e; }
}

AST valor() :
{ AST e; Token t; ArrayList<AST> argumentos; String cad;}
{
        <INTEGER> {
            return new Valor(new Tipo(TipoDato.INTEGER, TipoEstructura.VECTOR), new Vector(Arrays.asList(Integer.parseInt(token.image))), token.beginLine, token.beginColumn); }
        |
        <NUMERIC> {
            return new Valor(new Tipo(TipoDato.NUMERIC, TipoEstructura.VECTOR), new Vector(Arrays.asList(Double.parseDouble(token.image))), token.beginLine, token.beginColumn); }
        |
        <BOOLEAN> {
            return new Valor(new Tipo(TipoDato.BOOLEAN, TipoEstructura.VECTOR), new Vector(Arrays.asList(Boolean.parseBoolean(token.image))), token.beginLine, token.beginColumn);}
        |
        <NULL> {
            return new Valor(new Tipo(TipoDato.STRING, TipoEstructura.VECTOR), new Vector(Arrays.asList(token.image)), token.beginLine, token.beginColumn);}
        |
        t=<STRING> {
            cad = t.image.substring(1,t.image.length()-1);
            cad = cad.replace("\\","\\");
            cad = cad.replace("\\n","\n");
            cad = cad.replace("\\t","\t");
            return new Valor(new Tipo(TipoDato.STRING, TipoEstructura.VECTOR), new Vector(Arrays.asList(cad)), token.beginLine, token.beginColumn);}
        |
        LOOKAHEAD(2) e = llamada() { return e; }
        |
        LOOKAHEAD(2) e = accesoEstructura() { return e; }
        |
        t = <IDENTIFICADOR> {
                return new Identificador(t.image.trim(), token.beginLine, token.beginColumn); }
        |
        <DEFAULT_WORD> { return new ArgumentoDefault(); }
        |
        <PARINI> e=expresion() <PAREND> {return e;}
}